#!/usr/bin/env python
import os
import cv2
import sys

import time

import rospy
import argparse
import pickle
import rosbag

from cv_bridge import CvBridge
from front_end.srv import singleImageDescription,singleImageDescriptionRequest,singleImageDescriptionResponse
from front_end.srv import singleImageDetection,singleImageDetectionRequest,singleImageDetectionResponse
from front_end.utils import *
from front_end.

cvb=CvBridge()

if __name__ == '__main__':
    rospy.init_node('extract_loop_features')

    # parser = argparse.ArgumentParser()
    # parser.add_argument("stereo_bag_dir")
    # parser.add_argument("curve_dir")
    # parser.add_argument("key")
    # args = parser.parse_args()

    # pickleFile=open(args.curve_dir,"r")
    # inputSettings=pickle.load(pickleFile)
    # pickleFile.close()
    # print("settings Loaded")
    # print(inputSettings["operatingCurves"].keys())
    # print("beginning Sequence")

    # print("extracting images from : "+args.stereo_bag_dir)
    # inputBag=rosbag.Bag(args.stereo_bag_dir)
    # leftImages=[]
    # rightImages=[]

    # print("extracting Topic Data")
    # for topic,msg,t in inputBag.read_messages(topics=['/bumblebee/left/ROI','/bumblebee/right/ROI']):
    #     if(topic=="/bumblebee/left/ROI"):
    #         leftImages.append(msg)
    #     if(topic=="/bumblebee/right/ROI"):
    #         rightImages.append(msg)
    #     print(len(leftImages))
    #     if((len(leftImages)+len(rightImages))>=2*len(inputSettings["operatingCurves"][args.key])):
    #         print("halted image loading at total = "+str(len(inputSettings["operatingCurves"][args.key])))
    #         break
    # inputBag.close()
    # ####establish service connections
    # kpServiceName="feature_node/singleImageDetection"
    # descriptorServiceName="feature_node/singleImageDescription"
    # rospy.wait_for_service(kpServiceName)
    # rospy.wait_for_service(descriptorServiceName)

    # kpService=rospy.ServiceProxy(kpServiceName,singleImageDetection)
    # descriptorService=rospy.ServiceProxy(descriptorServiceName,singleImageDescription)

    # ###make default service request messages

    # kpRequest=singleImageDetectionRequest()
    # kpRequest.detectorName=inputSettings["name"]
    # kpRequest.returnKP=True

    # descriptorRequest=singleImageDescriptionRequest()


    # results={}
    # results["detectorName"]=inputSettings["name"]

    # results["descriptorTypes"]=[]
    # types=getAllDescriptor_Attributes()
    # for id in range(0,len(types)):
    #     results["descriptorTypes"].append(id)
    # results["curveID"]=args.key
    # results["frames"]=[]
    # outputName=args.curve_dir[:args.curve_dir.rfind("/")]+"/"+args.key+"_features.p"
    # for f in range(0,len(leftImages)):
    #     ###get KPS
    #     kpRequest.leftImg=leftImages[f]
    #     kpRequest.rightImg=rightImages[f]
    #     kpRequest.det_attrib.append(inputSettings["operatingCurves"][args.key][f])
    #     ans=kpService(kpRequest)

    #     descriptorRequest.leftImg=leftImages[f]
    #     descriptorRequest.rightImg=rightImages[f]
    #     descriptorRequest.leftFeatures=ans.outputFrames[0].leftFeatures
    #     descriptorRequest.rightFeatures=ans.outputFrames[0].rightFeatures
    #     print("startingReq")
    #     ans2=descriptorService(descriptorRequest)
    #     print("endReq")
    #     results["frames"].append(ans2)
    #     print(f)
    # outFile=open(outputName,"w")
    # print("outFile",outputName)
    # pickle.dump(results,outFile)
    # outFile.close()
    # print("completed")
